{"ast":null,"code":"import _slicedToArray from \"/media/disk1/projects/depub.space/node_modules/next/dist/compiled/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/media/disk1/projects/depub.space/node_modules/next/dist/compiled/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectDestructuringEmpty from \"/media/disk1/projects/depub.space/node_modules/next/dist/compiled/@babel/runtime/helpers/esm/objectDestructuringEmpty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from \"./../../theme/base\";\nimport { getClosestBreakpoint, findLastValidBreakpoint, hasValidBreakpointFormat, extractInObject } from \"./../../theme/tools\";\nimport { useContrastText } from \"../useContrastText\";\nexport function extractProps(props, theme, _ref, componentTheme, currentBreakpoint) {\n  _objectDestructuringEmpty(_ref);\n\n  var newProps = {};\n\n  for (var property in props) {\n    if (themePropertyMap[property]) {\n      var propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (var nestedProp in propValues) {\n          newProps[nestedProp] = get(theme, \"\".concat(themePropertyMap[nestedProp], \".\").concat(propValues[nestedProp]), propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        var shadowProps = theme[themePropertyMap[property]][props[property]];\n\n        if (!isNil(shadowProps)) {\n          newProps = _objectSpread(_objectSpread({}, newProps), shadowProps);\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n    }\n  }\n\n  return cloneDeep(newProps);\n}\n\nfunction filterDefaultProps(props, defaultProps) {\n  var _extractInObject = extractInObject(defaultProps, Object.keys(props)),\n      _extractInObject2 = _slicedToArray(_extractInObject, 2),\n      resultProps = _extractInObject2[1];\n\n  return resultProps;\n}\n\nexport var extractPropertyFromFunction = function extractPropertyFromFunction(property, props, theme, componentTheme) {\n  var propValues;\n\n  if (componentTheme && typeof componentTheme[themePropertyMap[property]] === 'function') {\n    var funcProps = componentTheme[themePropertyMap[property]](_objectSpread({\n      theme: theme\n    }, props));\n    var isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    });\n    propValues = isNested ? _objectSpread({}, get(funcProps, \"\".concat(props[property]))) : _objectSpread({}, funcProps);\n  } else {\n    propValues = get(componentTheme, \"\".concat(themePropertyMap[property], \".\").concat(props[property]));\n  }\n\n  return propValues;\n};\nexport function mergeUnderscoreProps(newProps, props) {\n  var _s = $RefreshSig$();\n\n  var _props = Object.keys(newProps).filter(function (propName) {\n    return propName.startsWith('_');\n  });\n\n  _props.forEach(_s(function (propName) {\n    _s();\n\n    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName;\n\n    var bg = (_newProps$bg = newProps.bg) !== null && _newProps$bg !== void 0 ? _newProps$bg : newProps.backgroundColor;\n    var textColor = bg ? {\n      color: useContrastText(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) === null || _newProps$propName === void 0 ? void 0 : _newProps$propName.color) !== null && _newProps$propName$co !== void 0 ? _newProps$propName$co : (_props$propName = props[propName]) === null || _props$propName === void 0 ? void 0 : _props$propName.color)\n    } : {};\n    newProps[propName] = _objectSpread(_objectSpread(_objectSpread({}, textColor), newProps[propName]), props[propName]);\n  }, \"au9PS1pGMSvlwCC87VHk+2CfJX8=\", false, function () {\n    return [useContrastText];\n  }));\n\n  return newProps;\n}\nexport var resolveValueWithBreakpoint = function resolveValueWithBreakpoint(values, breakpointTheme, currentBreakpoint, property) {\n  if (hasValidBreakpointFormat(values, breakpointTheme, property)) {\n    return findLastValidBreakpoint(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\nexport function calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {\n  var currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n\n  if (!props) {\n    props = {};\n  }\n\n  var newProps;\n\n  if (componentTheme) {\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint);\n    var componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle(_objectSpread(_objectSpread(_objectSpread({\n      theme: theme\n    }, newProps), props), colorModeProps));\n    newProps = mergeWith(newProps, componentBaseStyle, function (objValue, srcValue, key) {\n      if (!isNil(objValue)) {\n        delete newProps[key];\n      }\n    });\n    var variant = props.variant || get(componentTheme, 'defaultProps.variant');\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      var colorScheme = props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      var variantProps = componentTheme.variants[variant](_objectSpread(_objectSpread(_objectSpread({}, props), newProps), {}, {\n        colorScheme: colorScheme,\n        theme: theme\n      }, colorModeProps));\n      variantProps = extractProps(variantProps, theme, colorModeProps, componentTheme, currentBreakpoint);\n      newProps = mergeWith(newProps, variantProps, function (objValue, srcValue, key) {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  }\n\n  var extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint);\n  newProps = mergeWith(newProps, extractedProps, function (objValue, srcValue, key) {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n;\n\nvar _a, _b;\n\nif (typeof self !== 'undefined' && '$RefreshHelpers$' in self) {\n  var currentExports = module.__proto__.exports;\n  var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n  self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n\n  if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n    module.hot.dispose(function (data) {\n      data.prevExports = currentExports;\n    });\n    module.hot.accept();\n\n    if (prevExports !== null) {\n      if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n        module.hot.invalidate();\n      } else {\n        self.$RefreshHelpers$.scheduleUpdate();\n      }\n    }\n  } else {\n    var isNoLongerABoundary = prevExports !== null;\n\n    if (isNoLongerABoundary) {\n      module.hot.invalidate();\n    }\n  }\n}","map":{"version":3,"sources":["/media/disk1/projects/depub.space/node_modules/native-base/lib/module/hooks/useThemeProps/utils.js"],"names":["newProps","themePropertyMap","propValues","extractPropertyFromFunction","isNil","get","property","shadowProps","theme","props","resolveValueWithBreakpoint","cloneDeep","resultProps","extractInObject","Object","componentTheme","funcProps","isNested","_props","propName","bg","_newProps$bg","textColor","color","useContrastText","_newProps$propName$co","_newProps$propName","_props$propName","hasValidBreakpointFormat","findLastValidBreakpoint","currentBreakpoint","getClosestBreakpoint","extractProps","filterDefaultProps","componentBaseStyle","mergeWith","variant","colorScheme","variantProps","extractedProps","mergeUnderscoreProps"],"mappings":"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","sourcesContent":["import get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from './../../theme/base';\nimport { getClosestBreakpoint, findLastValidBreakpoint, hasValidBreakpointFormat, extractInObject } from './../../theme/tools';\nimport { useContrastText } from '../useContrastText';\n/*\n Extract props from theme props and omit those from props\n*/\n\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\n\nexport function extractProps(props, theme, {}, componentTheme, currentBreakpoint) {\n  let newProps = {};\n\n  for (let property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (themePropertyMap[property]) {\n      let propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (let nestedProp in propValues) {\n          newProps[nestedProp] = get(theme, \"\".concat(themePropertyMap[nestedProp], \".\").concat(propValues[nestedProp]), propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        let shadowProps = theme[themePropertyMap[property]][props[property]];\n\n        if (!isNil(shadowProps)) {\n          newProps = { ...newProps,\n            ...shadowProps\n          };\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n    }\n  }\n\n  return cloneDeep(newProps);\n}\n/*\nRemove props from defaultProps that are already present in props\n*/\n\nfunction filterDefaultProps(props, defaultProps) {\n  let [, resultProps] = extractInObject(defaultProps, Object.keys(props));\n  return resultProps;\n}\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\n\n\nexport const extractPropertyFromFunction = (property, props, theme, componentTheme) => {\n  let propValues; // Check if the entry in the theme is a function then calling it with all theme and props as params\n\n  if (componentTheme && typeof componentTheme[themePropertyMap[property]] === 'function') {\n    let funcProps = componentTheme[themePropertyMap[property]]({\n      theme,\n      ...props\n    }); // Check if returned object from componentTheme is a nested object\n\n    let isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    }); // If the returned value is nested object then find the property value in it, otherwise return the whole object\n\n    propValues = isNested ? { ...get(funcProps, \"\".concat(props[property]))\n    } : { ...funcProps\n    };\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = get(componentTheme, \"\".concat(themePropertyMap[property], \".\").concat(props[property]));\n  }\n\n  return propValues;\n};\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\n\nexport function mergeUnderscoreProps(newProps, props) {\n  const _props = Object.keys(newProps).filter(propName => propName.startsWith('_'));\n\n  _props.forEach(propName => {\n    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName;\n\n    // Adding color based on bg contrast if no color is given\n    const bg = (_newProps$bg = newProps.bg) !== null && _newProps$bg !== void 0 ? _newProps$bg : newProps.backgroundColor;\n    const textColor = bg ? {\n      color: useContrastText(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) === null || _newProps$propName === void 0 ? void 0 : _newProps$propName.color) !== null && _newProps$propName$co !== void 0 ? _newProps$propName$co : (_props$propName = props[propName]) === null || _props$propName === void 0 ? void 0 : _props$propName.color)\n    } : {}; // Overriding calculated props with user added props\n\n    newProps[propName] = { ...textColor,\n      ...newProps[propName],\n      ...props[propName]\n    };\n  });\n\n  return newProps;\n}\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\n\nexport const resolveValueWithBreakpoint = (values, breakpointTheme, currentBreakpoint, property) => {\n  if (hasValidBreakpointFormat(values, breakpointTheme, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return findLastValidBreakpoint(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\n\nexport function calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {\n  let currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n\n  if (!props) {\n    props = {};\n  }\n\n  let newProps;\n\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint); // Extracting props from base style\n\n    let componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle({\n      theme,\n      ...newProps,\n      ...props,\n      ...colorModeProps\n    });\n    newProps = mergeWith(newProps, componentBaseStyle, // @ts-ignore\n    (objValue, srcValue, key) => {\n      if (!isNil(objValue)) {\n        delete newProps[key];\n      }\n    });\n    const variant = props.variant || get(componentTheme, 'defaultProps.variant'); // Extracting props from variant\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      const colorScheme = props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      let variantProps = componentTheme.variants[variant]({ ...props,\n        ...newProps,\n        colorScheme,\n        theme,\n        ...colorModeProps\n      });\n      variantProps = extractProps(variantProps, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n\n      newProps = mergeWith(newProps, variantProps, // @ts-ignore\n      (objValue, srcValue, key) => {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  } // Extracting props from normal props\n\n\n  let extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n  // @ts-ignore\n\n  newProps = mergeWith(newProps, extractedProps, (objValue, srcValue, key) => {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}